---
title: 「JavaSE学习笔记09」Junit、反射、注解
author: JoyDee
categories: [Java, JavaSE]
tags: [JavaSE]
date: 2021-02-04 23:51:00 +0800
math: true
---

# Chapter 15. Junit单元测试

## 15.1 软件测试方法

+ 白盒测试（结构测试）：测试者清楚待测试对象内部工作机制，该测试是开发者测试自己设计编码的代码。而接下来要讨论的 Junit 即是基于白盒测试
+ 黑盒测试（功能测试）：通过测试检验是否每个功能都能正常工作，检查程序功能是否按**规格说明书**的规定正常使用，这是在程序接口进行的测试。

## 15.2 Junit使用步骤

1. 定义一个测试类，命名建议如下：

   + 测试类的名称：`被测试的类名Test.java`，如`CalculatorTest`；
   + 包名称：`xxx.xxx.xx.test`

2. 定义测试方法（能够在IDE中独立运行的模块），其定义建议如下：

   + 方法名：test被测试的方法名称
   + 返回值：`void`
   + 参数列表：空参

3. 给方法加上 `@Test` 的注解

   > 此外，在这个测试类中，还能对另一些方法，加上这些注解：
   >
   > + `@Before`：常用于资源的申请，修饰的方法会在测试方法之前被自动执行
   > + `@After`：与上相反的情况。

4. 导入 Junit 依赖环境

   > IDEA中鼠标指向红线处，即能够导入 Junit 各种依赖环境了。
   >
   > <img src="https://gitee.com/j__strawhat/MyImages/raw/master/20210205204432.png" style="zoom:80%;" />

5. 点击你需要测试的方法的首行右侧绿色按钮，便能够单独地运行该方法。

6. 通过 断言语句 来判断测试结果与期望的结果是否一致。

   ```java
   Assert.assertEquals(期望的结果,运算的结果);
   ```

## 案例演示

项目结构：

```
JoyDee
├─ LearningJunit
|  └─ Calculator.java
|
└─ test
   └─ CalculatorTest.java
```

```java
package JoyDee.LearningJunit;

public class Calculator {
    public int addNums(int a, int b){
        return a + b;
    }
    public int subNums(int a, int b){
        int tmp = a / 0; /* 此处作为错误演示 */
        return a - b;
    }
    public int mulNums(int a, int b){
        return a * a;
    }
}
```

```java
package JoyDee.test;

import JoyDee.LearningJunit.Calculator;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test; /* 4.导入junit依赖 */

public class CalculatorTest { /* 2.定义测试方法 */
    @Test       /* 3.为方法添加@Test注解 */
    public void testAddNums(){
        Calculator c = new Calculator();
        int res = c.addNums(1,2);
        System.out.println(res);
    }

    @Test
    public void testSubNums(){
        Calculator c = new Calculator();
        int res = c.subNums(1, 2);
        System.out.println(res);
    }

    @Test
    public void testMulNums(){
        Calculator c = new Calculator();
        int res = c.mulNums(2, 3);
        Assert.assertEquals(6, res); /* 期望值 与 测试值 进行比较 */
    }

    @Before /*所有测试方法执行之前，必须先执行该方法*/
    public void init(){
        System.out.println("Initializing...");
    }

    @After /*所有测试方法执行之后，必须先执行该方法*/
    public void close(){
        System.out.println("Closing the resource...");
    }

}
```

<img src="https://gitee.com/j__strawhat/MyImages/raw/master/20210205204900.png" style="zoom:70%;" />

<img src="https://gitee.com/j__strawhat/MyImages/raw/master/20210205205053.png" style="zoom:80%;" />

<img src="https://gitee.com/j__strawhat/MyImages/raw/master/20210205205439.png" style="zoom:80%;" />



# Chapter 16. 反射

## 16.1 Java类的加载

<img src="https://gitee.com/j__strawhat/MyImages/raw/master/14923529-ac753500687cf9d2.png"/>

> 如上图，Java类的完整加载机制分上面的七个阶段，现在讨论的是“加载”，是Java类的完整加载机制的第一个阶段。

参考了["学习java应该如何理解反射？"——Kira的知乎回答](https://www.zhihu.com/question/24304289/answer/147529485)，假定你需要运行下面这个代码：

```java
Object o = new Object();
```

首先这段代码通过 javac 编译成一个 `.class` 的二进制文件，然后通过 类加载器（ClassLoader）加载进JVM的内存中（此时，类 `Object` 加载到内存的方法区中）。

接着，创建了 `Object` 类的**`Class` 对象**（类型对象，每个类只有一个 `Class` 对象，作为方法区类的数据结构的接口。故并不是你 `new` 出来的实例对象！）

JVM 创建一个实例对象前，会先检查这个对象所属的类是否被加载，寻找该类对应的 `Class` 对象。若已经加载好，则会为你需要的对象**分配内存**，初始化（即 `new Object()`）

## 16.2 反射概述

Java的反射（reflection）机制，是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。

这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。反射被视为动态语言的关键。

此外，通过反射，我们能够解耦，提高程序的可扩展性。

下面的`.java`文件、`.class`文件、`Class`类的关系图，源自[bravo1988的回答](学习java应该如何理解反射？ - bravo1988的回答 - 知乎 https://www.zhihu.com/question/24304289/answer/694344906)。

> `Class` 类对反射的支持写了内部类，里面的字段与 `.class` 文件的内容形成映射

<img src="https://gitee.com/j__strawhat/MyImages/raw/master/v2-de522e669207c17994cf7394a9f23670_r.jpg"/>

## 16.3 Class对象及其内部成员的获取方法

获取 `Class` 对象的方法共三个：（获取的 `Class` 对象，都是**一样**的！）

1. 将字节码文件（`.class`）加载进内存，返回 `Class` 对象：`Class.forName("全类名")`（全类名，即" `包名.类名` "），举例如下：

   ```java
   Class cls1 = Class.forName("top.JoyDee.Person");
   ```

   多用于配置文件，将类名定义在配置文件中，读入文件，加载类。

2. 通过**类名**的属性 `class` 来获取：`类名.class`，举例如下：

   ```java
   Class cls2 = Person.class;
   ```

   多用于参数的传递。

3. **对象**继承了 `Object` 类定义的 `getClass()` 方法：`对象.getClass`

   ```java
   Person a = new Person();
   Class cls3 = a.getClass();
   ```

   多用在，有了对象，要获取其对应的字节码文件对象。

通过 `Class` 对象的方法，获取其内部成员：

一、获取成员变量们：

+ 获取所有 `public` 修饰的成员变量：`Field[] getFields()`

  ```java
  Class personCls = Person.class; //获取Person的Class对象
  Field[] fs = personCls.getFields(); //获取所有public修饰的成员变量
  for(Field fe : fs){
      System.out.println(fe);
  }
  ```

* 获取**指定名称**的 public修饰的成员变量：`Field getField(String name)`
* 获取**所有**的成员变量（包括`private`、`protected`、`public`及默认），不考虑修饰符：`Field[] getDeclaredFields()`
* 获取指定名称的 且不考虑修饰 的成员变量：`Field getDeclaredField(String name)`

二、获取构造器们：

+ `Constructor<?>[] getConstructors()`

+ `Constructor<T> getConstructor(类<?>... parameterTypes)` （括号中是某个构造器的 参数类型 的 `Class` 对象列表）

  ```java
  Class personCls = Person.class;
  Constructor c = personCls.getConstructor(String.class, int.class);
  ```

+ `Constructor<T> getDeclaredConstructor(类<?>... parameterTypes)`

+ `Constructor<?>[] getDeclaredConstructors()`

三、获取成员方法们：

+ 获取本类及**父类或父接口**的所有**公共**方法：`Method[] getMethods()`

+ `Method getMethod(String name, 类<?>... parameterTypes)`

  > 注意，与 获取构造器 不同在于，获取成员方法，需要传入（方法名，参数类型的`Class`对象列表）

+ 获取**本类**中的**所有**方法（包括`private`、`protected`、`public`及默认）`Method[] getDeclaredMethods()`

+ `Method getDeclaredMethod(String name, 类<?>... parameterTypes)`

四、获取**全类**名：`String getName()`

```java
Class personCls = Person.class;
String className = personCls.getName();
System.out.println(className); /* JoyDee.LearningReflection.Person */
```



## 16.4 成员变量、构造器、成员方法相关API

`Field`：成员变量

+ 设置值：`void set(Object obj, Object value)`

+ 获取值：`get(Object obj)`

+ 忽略访问权限修饰符的安全检查：`成员变量.setAccessible(true)` 

  ```java
  Person p = new Person();
  
  Field ne = personCls.getField("name"); //获取相应字段的成员变量
  Object value = ne.get(p); //将p对象传进去，使其返回值
  ne.set(p, "Luffy"); //修改
  
  Field ie = personCls.getField("id");
  is.setAccessible(true);  //暴力反射
  Object value2 = ie.get(p);
  
  ```

`Constructor`：构造器

+ 创建其构造的对象：`T newInstance(Object... initargs)`

  ```java
  Class personCls = Person.class;
  Constructor c = personCls.getConstructor(String.class, int.class);
  Object person = c.newInstance("Luffy", 20);
  ```

`Method`：成员方法

+ 执行其方法：`Object invoke(Object obj, Object... args)  `

  ```java
  Class personCls = Person.class;
  Person p = new Person();
  Method eat_method = personCls.getMethod("eat"， String.class); //获取指定名称的方法
  eat_method.invoke(p, "饭"); //指向方法，传入 指定对象及方法参数列表
  ```

+ 获取方法名称：`String getName()`

+ 忽略访问权限修饰符的安全检查：

  ```java
  mymethod.setAccessible(true);
  ```



## 16.5 综合案例

+ 需求：写一个"框架"，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法。

+ 实现：

  + 配置文件
  + 反射

+ 步骤：

  1. 将需要创建的对象的全类名和需要执行的方法**定义在配置文件**中
  2. 在程序中加载读取配置文件
  3. 使用反射技术来加载类文件进内存
  4. 创建对象
  5. 执行方法

+ 代码：

  ```java
  package JoyDee.LearningReflection;
  
  import java.lang.reflect.Constructor;
  import java.lang.reflect.Field;
  import java.lang.reflect.Method;
  
  
  ```

  